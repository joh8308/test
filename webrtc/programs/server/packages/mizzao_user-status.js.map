{"version":3,"sources":["meteor://ğŸ’»app/packages/mizzao_user-status/status.coffee","meteor://ğŸ’»app/status.coffee.js"],"names":["UserConnections","activeSession","addSession","idleSession","loginSession","onStartup","removeSession","statusEvents","tryLogoutSession","Mongo","Collection","connection","Npm","require","EventEmitter","on","advice","conns","update","$set","date","loginTime","ipAddr","userAgent","find","userId","fetch","_","every","c","idle","$unset","Meteor","users","length","lastActivity","max","pluck","selector","multi","upsert","id","clientAddress","httpHeaders","emit","connectionId","conn","findOne","_id","$exists","logoutTime","remove","startup","onConnection","onClose","Date","Accounts","onLogin","info","user","publish","_session","connectionHandle","methods","timestamp","check","Match","OneOf","Number","UserStatus","connections","events","StatusInternals"],"mappings":"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","file":"/packages/mizzao_user-status.js","sourcesContent":["###\n  Apparently, the new api.export takes care of issues here. No need to attach to global namespace.\n  See http://shiggyenterprises.wordpress.com/2013/09/09/meteor-packages-in-coffeescript-0-6-5/\n\n  We may want to make UserSessions a server collection to take advantage of indices.\n  Will implement if someone has enough online users to warrant it.\n###\nUserConnections = new Mongo.Collection(\"user_status_sessions\", { connection: null })\n\nstatusEvents = new (Npm.require('events').EventEmitter)()\n\n###\n  Multiplex login/logout events to status.online\n\n  'online' field is \"true\" if user is online, and \"false\" otherwise\n\n  'idle' field is tri-stated:\n  - \"true\" if user is online and not idle\n  - \"false\" if user is online and idle\n  - null if user is offline\n###\nstatusEvents.on \"connectionLogin\", (advice) ->\n  update =\n    $set: {\n      'status.online': true,\n      'status.lastLogin': {\n        date: advice.loginTime\n        ipAddr: advice.ipAddr\n        userAgent: advice.userAgent\n      }\n    }\n\n  # unless ALL existing connections are idle (including this new one),\n  # the user connection becomes active.\n  conns = UserConnections.find(userId: advice.userId).fetch()\n  unless _.every(conns, (c) -> c.idle)\n    update.$set['status.idle'] = false\n    update.$unset =\n      'status.lastActivity': null\n  # in other case, idle field remains true and no update to lastActivity.\n\n  Meteor.users.update advice.userId, update\n  return\n\nstatusEvents.on \"connectionLogout\", (advice) ->\n  conns = UserConnections.find(userId: advice.userId).fetch()\n  if conns.length is 0\n    # Go offline if we are the last connection for this user\n    # This includes removing all idle information\n    Meteor.users.update advice.userId,\n      $set: {'status.online': false }\n      $unset:\n        'status.idle': null\n        'status.lastActivity': null\n  else if _.every(conns, (c) -> c.idle)\n    ###\n      All remaining connections are idle:\n      - If the last active connection quit, then we should go idle with the most recent activity\n\n      - If an idle connection quit, nothing should happen; specifically, if the\n        most recently active idle connection quit, we shouldn't tick the value backwards.\n        This may result in a no-op so we can be smart and skip the update.\n    ###\n    return if advice.lastActivity? # The dropped connection was already idle\n\n    Meteor.users.update advice.userId,\n      $set:\n        'status.idle': true\n        'status.lastActivity': _.max(_.pluck conns, \"lastActivity\")\n  return\n\n###\n  Multiplex idle/active events to status.idle\n  TODO: Hopefully this is quick because it's all in memory, but we can use indices if it turns out to be slow\n\n  TODO: There is a race condition when switching between tabs, leaving the user inactive while idle goes from one tab to the other.\n  It can probably be smoothed out.\n###\nstatusEvents.on \"connectionIdle\", (advice) ->\n  conns = UserConnections.find(userId: advice.userId).fetch()\n  return unless _.every(conns, (c) -> c.idle)\n  # Set user to idle if all the connections are idle\n  # This will not be the most recent idle across a disconnection, so we use max\n\n  # TODO: the race happens here where everyone was idle when we looked for them but now one of them isn't.\n  Meteor.users.update advice.userId,\n    $set:\n      'status.idle': true\n      'status.lastActivity': _.max(_.pluck conns, \"lastActivity\")\n  return\n\nstatusEvents.on \"connectionActive\", (advice) ->\n  Meteor.users.update advice.userId,\n    $set:\n      'status.idle': false\n    $unset:\n      'status.lastActivity': null\n  return\n\n# Reset online status on startup (users will reconnect)\nonStartup = (selector = {}) ->\n  Meteor.users.update selector,\n    {\n      $set: {\n        \"status.online\": false\n      },\n      $unset: {\n        \"status.idle\": null\n        \"status.lastActivity\": null\n      }\n    },\n    { multi: true }\n\n###\n  Local session modifification functions - also used in testing\n###\n\naddSession = (connection) ->\n  UserConnections.upsert connection.id,\n    $set: {\n      ipAddr: connection.clientAddress\n      userAgent: connection.httpHeaders['user-agent']\n    }\n  return\n\nloginSession = (connection, date, userId) ->\n  UserConnections.upsert connection.id,\n    $set: {\n      userId: userId\n      loginTime: date\n    }\n\n  statusEvents.emit \"connectionLogin\",\n    userId: userId\n    connectionId: connection.id\n    ipAddr: connection.clientAddress\n    userAgent: connection.httpHeaders['user-agent']\n    loginTime: date\n  return\n\n# Possibly trigger a logout event if this connection was previously associated with a user ID\ntryLogoutSession = (connection, date) ->\n  return false unless (conn = UserConnections.findOne({\n    _id: connection.id\n    userId: { $exists: true }\n  }))?\n\n  # Yes, this is actually a user logging out.\n  UserConnections.upsert connection.id,\n    $unset: {\n      userId: null\n      loginTime: null\n    }\n\n  statusEvents.emit \"connectionLogout\",\n    userId: conn.userId\n    connectionId: connection.id\n    lastActivity: conn.lastActivity # If this connection was idle, pass the last activity we saw\n    logoutTime: date\n\nremoveSession = (connection, date) ->\n  tryLogoutSession(connection, date)\n  UserConnections.remove(connection.id)\n  return\n\nidleSession = (connection, date, userId) ->\n  UserConnections.update connection.id,\n    $set: {\n      idle: true\n      lastActivity: date\n    }\n\n  statusEvents.emit \"connectionIdle\",\n    userId: userId\n    connectionId: connection.id\n    lastActivity: date\n  return\n\nactiveSession = (connection, date, userId) ->\n  UserConnections.update connection.id,\n    $set: { idle: false }\n    $unset: { lastActivity: null }\n\n  statusEvents.emit \"connectionActive\",\n    userId: userId\n    connectionId: connection.id\n    lastActivity: date\n  return\n\n###\n  Handlers for various client-side events\n###\nMeteor.startup(onStartup)\n\n# Opening and closing of DDP connections\nMeteor.onConnection (connection) ->\n  addSession(connection)\n\n  connection.onClose ->\n    removeSession(connection, new Date())\n\n# Authentication of a DDP connection\nAccounts.onLogin (info) ->\n  loginSession(info.connection, new Date(), info.user._id)\n\n# pub/sub trick as referenced in http://stackoverflow.com/q/10257958/586086\n# We used this in the past, but still need this to detect logouts on the same connection.\nMeteor.publish null, ->\n  # Return null explicitly if this._session is not available, i.e.:\n  # https://github.com/arunoda/meteor-fast-render/issues/41\n  return [] unless @_session?\n\n  # We're interested in logout events - re-publishes for which a past connection exists\n  tryLogoutSession(@_session.connectionHandle, new Date()) unless @userId?\n\n  return []\n\n# We can use the client's timestamp here because it was sent from a TimeSync\n# value, however we should never trust it for something security dependent.\n# If timestamp is not provided (probably due to a desync), use server time.\nMeteor.methods\n  \"user-status-idle\": (timestamp) ->\n    check(timestamp, Match.OneOf(null, undefined, Date, Number) )\n\n    date = if timestamp? then new Date(timestamp) else new Date()\n    idleSession(@connection, date, @userId)\n    return\n\n  \"user-status-active\": (timestamp) ->\n    check(timestamp, Match.OneOf(null, undefined, Date, Number) )\n\n    # We only use timestamp because it's when we saw activity *on the client*\n    # as opposed to just being notified it. It is probably more accurate even if\n    # a dozen ms off due to the latency of sending it to the server.\n    date = if timestamp? then new Date(timestamp) else new Date()\n    activeSession(@connection, date, @userId)\n    return\n\n# Exported variable\nUserStatus =\n  connections: UserConnections\n  events: statusEvents\n\n# Internal functions, exported for testing\nStatusInternals = {\n  onStartup,\n  addSession,\n  removeSession,\n  loginSession,\n  tryLogoutSession,\n  idleSession,\n  activeSession,\n}\n","\n/*\n  Apparently, the new api.export takes care of issues here. No need to attach to global namespace.\n  See http://shiggyenterprises.wordpress.com/2013/09/09/meteor-packages-in-coffeescript-0-6-5/\n\n  We may want to make UserSessions a server collection to take advantage of indices.\n  Will implement if someone has enough online users to warrant it.\n */\nvar UserConnections, activeSession, addSession, idleSession, loginSession, onStartup, removeSession, statusEvents, tryLogoutSession;                             \n\nUserConnections = new Mongo.Collection(\"user_status_sessions\", {\n  connection: null\n});\n\nstatusEvents = new (Npm.require('events').EventEmitter)();\n\n\n/*\n  Multiplex login/logout events to status.online\n\n  'online' field is \"true\" if user is online, and \"false\" otherwise\n\n  'idle' field is tri-stated:\n  - \"true\" if user is online and not idle\n  - \"false\" if user is online and idle\n  - null if user is offline\n */\n\nstatusEvents.on(\"connectionLogin\", function(advice) {\n  var conns, update;\n  update = {\n    $set: {\n      'status.online': true,\n      'status.lastLogin': {\n        date: advice.loginTime,\n        ipAddr: advice.ipAddr,\n        userAgent: advice.userAgent\n      }\n    }\n  };\n  conns = UserConnections.find({\n    userId: advice.userId\n  }).fetch();\n  if (!_.every(conns, function(c) {\n    return c.idle;\n  })) {\n    update.$set['status.idle'] = false;\n    update.$unset = {\n      'status.lastActivity': null\n    };\n  }\n  Meteor.users.update(advice.userId, update);\n});\n\nstatusEvents.on(\"connectionLogout\", function(advice) {\n  var conns;\n  conns = UserConnections.find({\n    userId: advice.userId\n  }).fetch();\n  if (conns.length === 0) {\n    Meteor.users.update(advice.userId, {\n      $set: {\n        'status.online': false\n      },\n      $unset: {\n        'status.idle': null,\n        'status.lastActivity': null\n      }\n    });\n  } else if (_.every(conns, function(c) {\n    return c.idle;\n  })) {\n\n    /*\n      All remaining connections are idle:\n      - If the last active connection quit, then we should go idle with the most recent activity\n    \n      - If an idle connection quit, nothing should happen; specifically, if the\n        most recently active idle connection quit, we shouldn't tick the value backwards.\n        This may result in a no-op so we can be smart and skip the update.\n     */\n    if (advice.lastActivity != null) {\n      return;\n    }\n    Meteor.users.update(advice.userId, {\n      $set: {\n        'status.idle': true,\n        'status.lastActivity': _.max(_.pluck(conns, \"lastActivity\"))\n      }\n    });\n  }\n});\n\n\n/*\n  Multiplex idle/active events to status.idle\n  TODO: Hopefully this is quick because it's all in memory, but we can use indices if it turns out to be slow\n\n  TODO: There is a race condition when switching between tabs, leaving the user inactive while idle goes from one tab to the other.\n  It can probably be smoothed out.\n */\n\nstatusEvents.on(\"connectionIdle\", function(advice) {\n  var conns;\n  conns = UserConnections.find({\n    userId: advice.userId\n  }).fetch();\n  if (!_.every(conns, function(c) {\n    return c.idle;\n  })) {\n    return;\n  }\n  Meteor.users.update(advice.userId, {\n    $set: {\n      'status.idle': true,\n      'status.lastActivity': _.max(_.pluck(conns, \"lastActivity\"))\n    }\n  });\n});\n\nstatusEvents.on(\"connectionActive\", function(advice) {\n  Meteor.users.update(advice.userId, {\n    $set: {\n      'status.idle': false\n    },\n    $unset: {\n      'status.lastActivity': null\n    }\n  });\n});\n\nonStartup = function(selector) {\n  if (selector == null) {\n    selector = {};\n  }\n  return Meteor.users.update(selector, {\n    $set: {\n      \"status.online\": false\n    },\n    $unset: {\n      \"status.idle\": null,\n      \"status.lastActivity\": null\n    }\n  }, {\n    multi: true\n  });\n};\n\n\n/*\n  Local session modifification functions - also used in testing\n */\n\naddSession = function(connection) {\n  UserConnections.upsert(connection.id, {\n    $set: {\n      ipAddr: connection.clientAddress,\n      userAgent: connection.httpHeaders['user-agent']\n    }\n  });\n};\n\nloginSession = function(connection, date, userId) {\n  UserConnections.upsert(connection.id, {\n    $set: {\n      userId: userId,\n      loginTime: date\n    }\n  });\n  statusEvents.emit(\"connectionLogin\", {\n    userId: userId,\n    connectionId: connection.id,\n    ipAddr: connection.clientAddress,\n    userAgent: connection.httpHeaders['user-agent'],\n    loginTime: date\n  });\n};\n\ntryLogoutSession = function(connection, date) {\n  var conn;\n  if ((conn = UserConnections.findOne({\n    _id: connection.id,\n    userId: {\n      $exists: true\n    }\n  })) == null) {\n    return false;\n  }\n  UserConnections.upsert(connection.id, {\n    $unset: {\n      userId: null,\n      loginTime: null\n    }\n  });\n  return statusEvents.emit(\"connectionLogout\", {\n    userId: conn.userId,\n    connectionId: connection.id,\n    lastActivity: conn.lastActivity,\n    logoutTime: date\n  });\n};\n\nremoveSession = function(connection, date) {\n  tryLogoutSession(connection, date);\n  UserConnections.remove(connection.id);\n};\n\nidleSession = function(connection, date, userId) {\n  UserConnections.update(connection.id, {\n    $set: {\n      idle: true,\n      lastActivity: date\n    }\n  });\n  statusEvents.emit(\"connectionIdle\", {\n    userId: userId,\n    connectionId: connection.id,\n    lastActivity: date\n  });\n};\n\nactiveSession = function(connection, date, userId) {\n  UserConnections.update(connection.id, {\n    $set: {\n      idle: false\n    },\n    $unset: {\n      lastActivity: null\n    }\n  });\n  statusEvents.emit(\"connectionActive\", {\n    userId: userId,\n    connectionId: connection.id,\n    lastActivity: date\n  });\n};\n\n\n/*\n  Handlers for various client-side events\n */\n\nMeteor.startup(onStartup);\n\nMeteor.onConnection(function(connection) {\n  addSession(connection);\n  return connection.onClose(function() {\n    return removeSession(connection, new Date());\n  });\n});\n\nAccounts.onLogin(function(info) {\n  return loginSession(info.connection, new Date(), info.user._id);\n});\n\nMeteor.publish(null, function() {\n  if (this._session == null) {\n    return [];\n  }\n  if (this.userId == null) {\n    tryLogoutSession(this._session.connectionHandle, new Date());\n  }\n  return [];\n});\n\nMeteor.methods({\n  \"user-status-idle\": function(timestamp) {\n    var date;\n    check(timestamp, Match.OneOf(null, void 0, Date, Number));\n    date = timestamp != null ? new Date(timestamp) : new Date();\n    idleSession(this.connection, date, this.userId);\n  },\n  \"user-status-active\": function(timestamp) {\n    var date;\n    check(timestamp, Match.OneOf(null, void 0, Date, Number));\n    date = timestamp != null ? new Date(timestamp) : new Date();\n    activeSession(this.connection, date, this.userId);\n  }\n});\n\nUserStatus = {\n  connections: UserConnections,\n  events: statusEvents\n};\n\nStatusInternals = {\n  onStartup: onStartup,\n  addSession: addSession,\n  removeSession: removeSession,\n  loginSession: loginSession,\n  tryLogoutSession: tryLogoutSession,\n  idleSession: idleSession,\n  activeSession: activeSession\n};\n"]}